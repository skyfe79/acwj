# 64부: 8비트 CPU에서의 자기 컴파일

컴파일러 작성 여정의 새로운 장을 시작한다. 이번 목표는 1980년대 8비트 CPU에서 컴파일러가 스스로를 컴파일할 수 있도록 만드는 것이다. 이 작업은 흥미롭기도 하고, 때로는 즐겁기도, 때로는 고통스럽기도 했다. 여기서는 지금까지 해온 모든 작업을 요약해본다.

CPU로는 [Motorola 6809](https://en.wikipedia.org/wiki/Motorola_6809)를 선택했다. 이 CPU는 1980년대 가장 복잡한 8비트 CPU 중 하나로, 다양한 유용한 주소 지정 모드와 중요한 스택 포인터를 제공한다.

6809용 컴파일러를 작성하는 데 어려운 점은 주소 공간의 제한이다. 많은 8비트 CPU와 마찬가지로, 64K의 메모리(정확히 65,536바이트!)만 사용할 수 있다. 그리고 대부분의 구형 6809 시스템에서는 이 중 상당 부분이 ROM으로 차지된다.

2023년에 6809를 CPU로 사용하는 싱글 보드 컴퓨터(SBC)를 만들어보기로 결정했다. 특히, 최소 반 메가바이트의 메모리, 디스크 같은 저장 장치, 그리고 유닉스 같은 운영체제를 갖춘 기계를 원했다.

그 결과물이 바로 [MMU09 SBC](https://github.com/DoctorWkt/MMU09)다. 이 프로젝트는 아직 완전히 완성되지는 않았지만, 유닉스 같은 시스템을 가지고 있으며, 멀티태스킹도 가능하다. 단, 선점형 멀티태스킹은 지원하지 않는다. 각 프로세스는 63.5K의 사용 가능한 주소 공간(즉, RAM)을 갖는다.

MMU09를 작업하면서 운영체제, 라이브러리, 애플리케이션의 코드를 컴파일할 적합한 C 컴파일러를 찾아야 했다. 처음에는 [CMOC](http://perso.b2b2c.ca/~sarrazip/dev/cmoc.html)를 사용했지만, 결국 [vbcc](http://www.compilers.de/vbcc.html)로 전환했다. 그 과정에서 Alan Cox의 [Fuzix Compiler Kit](https://github.com/EtchedPixels/Fuzix-Compiler-Kit)를 발견했다. 이는 많은 8비트와 16비트 CPU를 위한 진행 중인 C 컴파일러 프로젝트다.

이 모든 경험을 통해 한 가지 생각이 들었다: C 컴파일러가 더 강력한 시스템에서 크로스 컴파일하는 것이 아니라, 6809 자체에서 실행될 수 있을까? Fuzix Compiler Kit가 가능할 것 같았지만, 아니었다. 6809 자체에 맞추기에는 너무 크다.

그래서 이제 질문과 목표가 생겼다: "acwj" 컴파일러를 6809 플랫폼에서 실행될 수 있도록 수정할 수 있을까?


## 6809 CPU

컴파일러 작성자의 관점에서 6809 CPU를 살펴보자. 이미 64K 주소 공간 제한에 대해 언급했는데, 이는 "acwj" 컴파일러를 완전히 재구성해야 함을 의미한다. 이제 6809의 아키텍처를 자세히 살펴보자.

![](docs/6809_Internal_Registers.png)

Creative Commons CC0 라이선스, [Wikipedia](https://commons.wikimedia.org/wiki/File:6809_Internal_Registers.svg)

8비트 CPU인 6809는 상당히 많은 레지스터를 가지고 있다. 물론 x64나 RISC CPU처럼 다수의 범용 레지스터를 가진 것은 아니다. 논리 및 산술 연산을 수행할 수 있는 단일 16비트 `D` 레지스터가 있다. 이 레지스터는 두 개의 8비트 레지스터 `A`와 `B`로도 접근할 수 있으며, `B`는 `D` 레지스터의 최하위 바이트다.

논리 및 산술 연산을 수행할 때, 두 번째 피연산자는 주소 지정 모드를 통해 접근한 메모리 위치이거나 리터럴 값이다. 연산 결과는 항상 `D` 레지스터에 저장된다. 따라서 `D` 레지스터는 연산 결과를 누적한다.

메모리에 접근하기 위해 다양한 주소 지정 모드가 있다. 사실 컴파일러가 필요로 하는 것보다 훨씬 더 많은 모드가 제공된다! 예를 들어, 배열의 기본 주소를 알고 있고 `X`에 요소의 인덱스가 있는 경우, `X`와 `Y` 인덱스 레지스터를 사용해 배열 요소에 접근할 수 있다. 또한 부호 있는 상수와 스택 포인터 `S`를 인덱스로 사용해 메모리에 접근할 수도 있다. 이를 통해 `S`를 [프레임 포인터](https://en.wikipedia.org/wiki/Call_stack#FRAME-POINTER)로 취급할 수 있다. 함수의 지역 변수는 프레임 포인터 아래 주소에서 찾을 수 있고, 함수 인수는 프레임 포인터 위 주소에서 찾을 수 있다.

위 내용을 더 명확히 이해하기 위해 몇 가지 예제를 살펴보자:

```
    ldd #2         # 상수 2를 D에 로드
    ldd 2          # 주소 2와 3에서 16비트 값을 D에 로드
    ldd _x         # _x로 알려진 위치에서 D에 로드
    ldd 2,s        # 스택의 인수에서 D에 로드
    std -20,s      # D의 값을 스택의 지역 변수에 저장
    leax 8,s       # S+8의 (유효) 주소를 가져와 X 레지스터에 저장
    ldd 4,x        # 이제 이를 int 배열의 포인터로 사용하고
                   # 인덱스 2의 값을 로드. D는 16비트(2바이트)이므로
                   # 4바이트는 두 개의 16비트 "워드"임
    addd -6,s      # 방금 가져온 int를 지역 변수에 더하고
                   # 결과를 D 레지스터에 저장
```

더 자세한 내용은 [6809 데이터시트](docs/6809Data.pdf)를 참조하기를 권한다. 5-6페이지는 레지스터를, 16-18페이지는 주소 지정 모드를, 25-27페이지는 사용 가능한 명령어 목록을 다룬다.

"acwj" 컴파일러를 6809로 포팅하는 문제로 돌아가자. 많은 주소 지정 모드를 사용할 수 있다는 것은 좋은 점이다. 8비트 값과 16비트 값을 다룰 수 있지만, 32비트 레지스터는 없다. 이 문제는 어떻게든 해결할 수 있을 것이다.

하지만 64K 주소 공간 외에도 가장 큰 문제는 "acwj" 컴파일러가 두 개 또는 세 개의 피연산자를 가진 명령어와 많은 수의 레지스터를 가진 아키텍처를 위해 작성되었다는 점이다. 예를 들어:

```
   load R1, _x		# _x와 _y를 레지스터에 로드
   load R2, _y
   add  R3, R1, R2	# R3= R1 + R2
   save R3, _z		# 결과를 _z에 저장
```

6809는 보통 `D` 레지스터를 하나의 피연산자로 사용하고, 메모리나 리터럴 값을 다른 피연산자로 사용한다. 결과는 항상 `D` 레지스터에 저장된다.


## QBE 백엔드 유지하기

나는 컴파일러에서 기존의 QBE 백엔드를 유지하고 싶었다. 이는 컴파일러를 변경할 때 매우 유용할 것이라고 생각했다. QBE와 6809 백엔드 모두로 테스트를 실행하고 결과를 비교할 수 있기 때문이다. 또한 QBE 백엔드를 사용해 삼중 테스트를 수행함으로써 컴파일러를 항상 스트레스 테스트할 수 있다.

이제 최종 목표는 다음과 같다: 컴파일러의 파서가 생성한 추상 구문 트리(AST)를 사용해 두 가지 완전히 다른 아키텍처(QBE와 6809)에 대한 어셈블리 코드를 생성할 수 있는가? 그리고 컴파일러가 두 아키텍처 모두에서 자체 컴파일을 수행할 수 있는가?

QBE는 RISC 스타일의 3-오퍼랜드 명령어를 사용하는 반면, 6809는 단 하나의 레지스터와 암시적 소스 및 목적지를 가진 2-오퍼랜드 명령어를 사용한다. 이 두 아키텍처에 대한 코드 생성을 동시에 지원하는 것은 흥미로운 도전이 될 것이다.

이 과정은 분명 흥미로운 여정이 될 것이다!


## 코드 생성기 계약

이제 두 가지 다른 백엔드를 사용하게 되면서, 아키텍처에 독립적인 코드 생성기 부분([gen.c](gen.c))과 각 아키텍처에 의존적인 부분 사이에 '계약' 또는 API가 필요하다. 이 계약은 [gen.h](gen.h)에 정의된 함수 목록으로 구성된다.

기본 API는 이전과 동일하다. 하나 이상의 "레지스터 번호"를 전달하면 결과를 담은 레지스터 번호를 반환한다. 이번에는 많은 함수가 아키텍처에 독립적인 피연산자의 `타입`을 받는다는 점이 다르다. 이 타입은 [defs.h](defs.h)에 정의되어 있다:

```
// 기본 타입. 하위 4비트는 간접 참조 수준을 나타내는 정수 값이다.
// 예: 0=포인터 없음, 1=포인터, 2=포인터의 포인터 등
enum {
  P_NONE, P_VOID = 16, P_CHAR = 32, P_INT = 48, P_LONG = 64,
  P_STRUCT=80, P_UNION=96
};
```

[QBE 코드 생성기](cgqbe.c)를 보면, 이전 "acwj" 여정에서 다룬 내용과 거의 동일하다. 한 가지 주목할 점은 파서와 코드 생성기가 이제 별도의 프로그램으로 분리되면서 몇 가지 함수를 [targqbe.c](targqbe.c)라는 별도의 파일로 추상화했다는 것이다.

이제 6809 코드 생성기를 살펴보자.


## 6809 프로세서의 특수 타입과 D 레지스터

6809 프로세서에서 여러 레지스터를 다루는 방법이 주요 문제다. 이에 대해 다음 섹션에서 자세히 다루겠지만, 우선 짧게 다른 내용을 먼저 살펴보겠다.

각 아키텍처에 의존적인 코드 생성기는 피연산자의 타입을 받는다. P_CHAR, P_INT 등이 그 예시다. 6809 코드 생성기의 경우, 이 타입들을 6809 전용 타입으로 변환한다. 이는 [cg6809.c](cg6809.c) 파일에 다음과 같이 정의되어 있다:

```
#define PR_CHAR         1	// 크기 1바이트
#define PR_INT          2	// 크기 2바이트
#define PR_POINTER      3	// 크기 2바이트
#define PR_LONG         4	// 크기 4바이트
```

이 파일에서는 다음과 같은 코드를 자주 볼 수 있다:

```
  int primtype= cgprimtype(type);

  switch(primtype) {
    case PR_CHAR:
      // char 연산을 생성하는 코드
    case PR_INT:
    case PR_POINTER:
      // int 연산을 생성하는 코드
    case PR_LONG:
      // long 연산을 생성하는 코드
  }
```

`PR_INT`와 `PR_POINTER`는 크기가 같고 동일한 코드를 생성하지만, 개념적으로 분리했다. 이는 포인터가 부호 없는(unsigned) 값인 반면, `int`는 부호 있는(signed) 값이기 때문이다. 나중에 컴파일러에 부호 있는 타입과 부호 없는 타입을 추가하게 되면, 이미 6809 백엔드에서 이 부분을 준비해 둔 셈이다.


## 레지스터가 없을 때 어떻게 처리할까?

이제 핵심 문제로 돌아가보자. 코드 생성기 API가 레지스터 번호를 사용하는데, 6809 CPU에는 단일 누산기인 `D`만 있다면 어떻게 백엔드를 작성할 수 있을까?

6809 백엔드를 처음 작성할 때, 나는 `R0, R1, R2` 등으로 불리는 4바이트 메모리 위치 세트로 시작했다. 이 내용은 [lib/6809/crt0.s](lib/6809/crt0.s) 파일에서 여전히 확인할 수 있다:

```
R0:     .word   0
        .word   0
R1:     .word   0
        .word   0
...
```

이 방법으로 6809 백엔드를 작동시킬 수 있었지만, 생성된 코드는 매우 비효율적이었다. 예를 들어, 다음과 같은 C 코드:

```
  int x, y, z;
  ...
  z= x + y;
```

는 다음과 같이 번역되었다:

```
  ldd  _x
  std  R0
  ldd  _y
  std  R1
  ldd  R0
  addd R1
  std  R2
  ldd  R2
  std  _z
```

그러다 6809가 매우 "주소" 지향적이라는 사실을 깨달았다. 다양한 주소 지정 모드가 있으며, 대부분의 명령어는 피연산자로 주소(또는 리터럴)를 사용한다. 따라서 "_위치_" 목록을 유지하기로 했다.

위치는 [cg6809.c](cg6809.c) 파일에 정의된 다음 중 하나이다:

```
enum {
  L_FREE,               // 사용되지 않는 위치
  L_SYMBOL,             // 옵셔널 오프셋이 있는 전역 심볼
  L_LOCAL,              // 지역 변수 또는 매개변수
  L_CONST,              // 정수 리터럴 값
  L_LABEL,              // 레이블
  L_SYMADDR,            // 심볼, 지역 변수 또는 매개변수의 주소
  L_TEMP,               // 임시 저장 값: R0, R1, R2 ...
  L_DREG                // D 위치, 즉 B, D 또는 Y/D
};
```

그리고 우리는 이 구조를 가진 사용 중이거나 사용 가능한 위치 목록을 유지한다:

```
struct Location {
  int type;             // L_ 값 중 하나
  char *name;           // 심볼 이름
  long intval;          // 오프셋, 상수 값, 레이블 ID 등
  int primtype;         // 6809 기본 타입
};
```

예시:

 - 전역 `int x`는 `name`이 "x"로 설정되고 `primtype`이 PR_INT로 설정된 L_SYMBOL이다.
 - 지역 `char *ptr`는 이름이 없지만 `intval`이 스택 프레임 내 오프셋(예: -8)으로 설정된 L_LOCAL이다. `primtype`은 PR_POINTER이다. 함수 매개변수라면 오프셋은 양수일 것이다.
 - 피연산자가 `&x`(x의 주소)와 같은 경우, 위치는 `name`이 "x"로 설정된 L_SYMADDR이다.
 - 456과 같은 리터럴 값은 `intval`이 456으로 설정되고 `primtype`이 PR_INT로 설정된 L_CONST이다.
 - 마지막으로, 피연산자가 이미 `D` 레지스터에 있다면, 특정 PR_ 타입을 가진 L_DREG 위치가 된다.

따라서, 위치는 레지스터를 대신한다. 우리는 16개의 위치 배열을 가지고 있다:

```
#define NUMFREELOCNS 16
static struct Location Locn[NUMFREELOCNS];
```

이제 6809에서 덧셈을 생성하는 코드를 살펴보자.

```
// 두 위치를 더하고 결과가 있는 위치 번호를 반환
int cgadd(int l1, int l2, int type) {
  int primtype= cgprimtype(type);

  load_d(l1);

  switch(primtype) {
    case PR_CHAR:
      fprintf(Outfile, "\taddb "); printlocation(l2, 0, 'b'); break;
    case PR_INT:
    case PR_POINTER:
      fprintf(Outfile, "\taddd "); printlocation(l2, 0, 'd'); break;
      break;
    case PR_LONG:
      fprintf(Outfile, "\taddd "); printlocation(l2, 2, 'd');
      fprintf(Outfile, "\texg y,d\n");
      fprintf(Outfile, "\tadcb "); printlocation(l2, 1, 'f');
      fprintf(Outfile, "\tadca "); printlocation(l2, 0, 'e');
      fprintf(Outfile, "\texg y,d\n");
  }
  cgfreelocn(l2);
  Locn[l1].type= L_DREG;
  d_holds= l1;
  return(l1);
}
```

먼저 일반 피연산자 타입에서 6809 타입을 결정한다. 그런 다음 첫 번째 위치 `l1`의 값을 `D` 레지스터에 로드한다. 그런 다음 6809 타입에 따라 올바른 명령어 세트를 출력하고 각 명령어 뒤에 두 번째 위치 `l2`를 출력한다.

덧셈이 완료되면 두 번째 위치를 해제하고 첫 번째 위치 `l1`이 이제 `D` 레지스터임을 표시한다. 또한 `D`가 이제 사용 중임을 기록한 후 반환한다.

위치 개념을 사용하면, C 코드 `z= x + y`는 이제 다음과 같이 번역된다:

```
  ldd  _x	; 즉 load_x(l1);
  addd _y	; 즉 fprintf(Outfile, "\taddd "); printlocation(l2, 2, 'd');
  std  _z	; 다른 함수인 cgstorglob()에서 수행
```


## 32비트 Long 타입 처리

6809 프로세서는 8비트와 16비트 연산을 지원하지만, 컴파일러는 32비트 long 타입 연산을 구현해야 한다. 또한, 32비트 레지스터가 존재하지 않는다.

> 참고: 6809는 빅 엔디안 방식이다. 만약 0x12345678이라는 long 값을 `foo`라는 변수에 저장한다면, 0x12는 `foo`의 오프셋 0, 0x34는 오프셋 1, 0x56은 오프셋 2, 0x78은 오프셋 3에 위치한다.

나는 [Fuzix Compiler Kit](https://github.com/EtchedPixels/Fuzix-Compiler-Kit)에서 Alan Cox가 사용한 방식을 차용했다. `Y` 레지스터를 사용해 32비트 long의 상위 16비트를 저장하고, `D` 레지스터를 사용해 하위 16비트를 저장한다:

![](docs/long_regs.png)

6809는 이미 `D` 레지스터의 하위 8비트를 `B` 레지스터로 사용하며, 8비트 연산에 활용한다. 그리고 `D` 레지스터의 상위 8비트는 `A` 레지스터로 사용한다.

위의 `cgadd()` 코드를 보면, `x`, `y`, `z`가 `int`가 아닌 `long` 타입일 때 다음과 같은 코드가 생성됨을 알 수 있다:

```
  ldd  _x+2	; _x의 하위 16비트를 D에 로드
  ldy  _x+0	; _x의 상위 16비트를 Y에 로드
  addd _y+2	; _y의 하위 16비트를 D에 더함
  exg  y,d	; Y와 D 레지스터 교환
  adcb _y+1	; _y의 오프셋 1 값을 B 레지스터에 캐리와 함께 더함
  adca _y+0	; _y의 오프셋 0 값을 A 레지스터에 캐리와 함께 더함
  exg  y,d	; Y와 D 레지스터를 다시 교환
  std  _z+2	; D(하위 16비트)를 _z의 오프셋 2에 저장
  sty  _z	; Y(상위 16비트)를 _z의 오프셋 0에 저장
```

이 과정은 다소 번거롭다. 16비트 `addd` 연산은 캐리를 지원하지 않기 때문에, 동일한 결과를 얻기 위해 두 번의 8비트 덧셈 연산을 수행해야 한다.

6809에서 제공하는 연산의 이러한 불일치로 인해, 6809 코드 생성기가 부분적으로 복잡하고 지저분해지는 문제가 발생한다.


# printlocation()

위치 정보를 처리하는 작업의 상당 부분은 `printlocation()` 함수가 담당한다. 이 함수를 몇 단계로 나누어 살펴보자.

```
// 위치 정보를 출력한다. 메모리 위치의 경우 오프셋을 사용한다.
// 상수의 경우 레지스터 문자를 사용해 어떤 부분을 출력할지 결정한다.
static void printlocation(int l, int offset, char rletter) {
  int intval;

  if (Locn[l].type == L_FREE)
    fatald("Error trying to print location", l);

  switch(Locn[l].type) {
    case L_SYMBOL: fprintf(Outfile, "_%s+%d\n", Locn[l].name, offset); break;
    case L_LOCAL: fprintf(Outfile, "%ld,s\n",
                Locn[l].intval + offset + sp_adjust);
        break;
    case L_LABEL: fprintf(Outfile, "#L%ld\n", Locn[l].intval); break;
    case L_SYMADDR: fprintf(Outfile, "#_%s\n", Locn[l].name); break;
    case L_TEMP: fprintf(Outfile, "R%ld+%d\n", Locn[l].intval, offset);
        break;
    ...
```

위치가 L_FREE 타입이라면 출력할 필요가 없다!  
심볼의 경우, 심볼 이름 뒤에 오프셋을 붙여 출력한다. 이렇게 하면 `int`나 `long` 타입의 심볼을 구성하는 모든 바이트에 접근할 수 있다: `_x+0`, `_x+1`, `_x+2`, `_x+3`.

로컬 변수와 함수 파라미터의 경우, 스택 프레임 내 위치를 출력한다(즉, `intval`에 오프셋을 더한 값). 예를 들어 로컬 `long` 변수 `fred`가 스택의 -12 위치에 있다면, `-12,s`, `-11,s`, `-10,s`, `-9,s`로 모든 네 바이트에 접근할 수 있다.

여기서 `sp_adjust`라는 것이 등장한다. 이에 대해서는 곧 설명할 예정이다!

이제 L_TEMP 위치를 살펴보자. 이전 버전의 컴파일러와 마찬가지로, 중간 결과를 어딘가에 저장해야 하는 경우가 있다. 예를 들어:

```
  int z= (a + b) * (c - d) / (e + f) * (g + h - i) * (q - 3);
```

위 식에서는 괄호 안의 다섯 가지 중간 결과가 곱셈과 나눗셈을 수행하기 전에 필요하다. 이때 가상의 레지스터 R0, R1, R2 등이 유용하게 쓰인다! 중간 결과를 임시로 저장해야 할 때, 이 위치를 할당하고 중간 결과를 여기에 저장한다. 이 작업은 [cg6809.c](cg6809.c) 파일의 `cgalloctemp()`과 `cgfreealltemps()` 함수가 처리한다.


# printlocation()와 리터럴 값

대부분의 위치에서는 단순히 위치의 이름이나 스택 상의 위치를 출력하고, 필요한 오프셋을 더하면 된다. 코드 생성기는 이미 실행할 명령어를 출력했기 때문에 다음과 같이 처리한다.

```
  ldb _x+0	; _x에서 한 바이트를 B에 로드
  ldd _x+0	; _x에서 두 바이트를 D에 로드
```

하지만 리터럴 값, 예를 들어 0x12345678의 경우, 끝의 0x78을 출력해야 할지, 아니면 0x5678을 출력해야 할지 고민할 수 있다. 또는 덧셈 코드에서 0x34와 0x12에도 접근해야 할지 고민할 수 있다.

이런 이유로 `printlocation()`에는 `rletter` 매개변수가 있다.

```
static void printlocation(int l, int offset, char rletter);
```

리터럴 값을 출력할 때 이 매개변수를 사용해 어떤 부분을 얼마나 출력할지 선택한다. 6809의 레지스터 이름을 반영한 값을 선택했지만, 몇 가지는 새로 만들었다. 리터럴 0x12345678의 경우:

 - 'b'는 0x78 부분을 출력
 - 'a'는 0x56 부분을 출력
 - 'd'는 0x5678 부분을 출력
 - 'y'는 0x1234 부분을 출력
 - 'f'는 0x34 부분을 출력
 - 'e'는 0x12 부분을 출력

이 방식으로 리터럴 값의 특정 부분을 선택적으로 출력할 수 있다.


## 헬퍼 함수

컴파일러가 수행해야 하지만 6809 프로세서가 직접 지원하지 않는 연산들이 있다. 곱셈, 나눗셈, 여러 비트 단위 시프트 등이 그 예시다.

이 문제를 해결하기 위해 [Fuzix Compiler Kit](https://github.com/EtchedPixels/Fuzix-Compiler-Kit)에서 여러 헬퍼 함수를 가져왔다. 이 함수들은 `lib/6809/lib6809.a` 아카이브 파일에 포함되어 있다. [cg6809.c](cg6809.c) 파일에 있는 `cgbinhelper()` 함수는 다음과 같다.

```
// 두 위치에서 값을 가져와 헬퍼 서브루틴을 실행한 후
// 결과가 저장된 위치 번호를 반환한다
static int cgbinhelper(int l1, int l2, int type,
                                char *cop, char *iop, char *lop);
```

이 함수는 `l1`과 `l2` 위치에서 값을 가져와 스택에 푸시한 다음, `cop`, `iop`, `lop`에 지정된 이름의 char/int/long 헬퍼 함수 중 하나를 호출한다. 따라서 코드 생성기에서 곱셈을 수행하는 함수는 다음과 같이 간단히 구현할 수 있다.

```
// 두 위치의 값을 곱한 후
// 결과가 저장된 위치 번호를 반환한다
int cgmul(int r1, int r2, int type) {
  return(cgbinhelper(r1, r2, type, "__mul", "__mul", "__mull"));
}
```


# 로컬 변수와 파라미터의 위치 추적

함수의 로컬 변수나 파라미터는 스택에 저장된다. 이 변수들은 스택 포인터를 기준으로 한 오프셋을 통해 접근한다. 예를 들어:

```
  ldd -12,s     ; 스택 포인터에서 12바이트 아래에 있는 로컬 정수 변수를 로드
```

하지만 여기서 문제가 발생한다. 스택 포인터가 이동하면 어떻게 될까? 다음 코드를 보자:

```
int main() {
 int x;
 
 x= 2; printf("%d %d %d\n", x, x, x);
 return(0);
}
```

`x`는 스택 포인터를 기준으로 오프셋 0에 위치할 수 있다. 하지만 `printf()`를 호출할 때 `x`의 복사본을 스택에 푸시한다. 이제 실제 `x`는 위치 2에 있게 된다. 따라서 실제로는 다음과 같은 코드를 생성해야 한다:

```
  ldd 0,s	; x의 값을 가져옴
  pshs d	; 스택에 푸시
  ldd 2,s	; x의 값을 가져옴, 새로운 오프셋 주의
  pshs d	; 스택에 푸시
  ldd 4,s	; x의 값을 가져옴, 새로운 오프셋 주의
  pshs d	; 스택에 푸시
  ldd #L2	; 문자열 "%d %d %d\n"의 주소를 가져옴
  pshs d	; 스택에 푸시
  lbsr _printf	; printf() 호출
  leas 8,s	; 스택에서 8바이트의 인수를 제거
```

로컬 변수와 파라미터의 현재 오프셋을 어떻게 추적할까? 답은 [cg6809.c](cg6809.c) 파일의 `sp_adjust` 변수에 있다. 스택에 무언가를 푸시할 때마다 푸시된 바이트 수만큼 `sp_adjust`에 더한다. 마찬가지로 스택에서 무언가를 풀거나 스택 포인터를 올리면 `sp_adjust`에서 해당 값을 뺀다. 예를 들어:

```
// 스택에 위치를 푸시
static void pushlocn(int l) {
  load_d(l);

  switch(Locn[l].primtype) {
    ...
    case PR_INT:
      fprintf(Outfile, "\tpshs d\n");
      sp_adjust += 2;
      break;
    ...
  }
  ...
}
```

또한 `printlocation()`에서 로컬 변수와 파라미터를 출력할 때:

```
    case L_LOCAL: fprintf(Outfile, "%ld,s\n",
                Locn[l].intval + offset + sp_adjust);
```

함수의 어셈블리 코드 생성을 마치면 약간의 오류 검사도 수행한다:

```
// 함수의 에필로그 출력
void cgfuncpostamble(struct symtable *sym) {
  ...
  if (sp_adjust !=0 ) {
    fprintf(Outfile, "; DANGER sp_adjust is %d not 0\n", sp_adjust);
    fatald("sp_adjust is not zero", sp_adjust);
  }
}
```

이것이 6809 어셈블리 코드 생성에 대해 다룰 내용의 전부이다. [cg6809.c](cg6809.c) 파일의 코드는 6809 명령어 세트의 복잡성을 처리해야 하기 때문에 [cgqbe.c](cgqbe.c) 파일보다 훨씬 크다. 하지만 [cg6809.c](cg6809.c) 파일에 충분한 주석을 달아두었으니 코드를 따라가며 이해할 수 있을 것이다.

`D` 레지스터가 사용 중인지 여부를 추적하는 것과 같은 몇 가지 까다로운 부분이 있으며, 모든 `long` 연산의 합성을 완벽하게 처리하지 못했을 수도 있다.

이제 6809의 64K 주소 제한이라는 더 큰 주제를 다룰 차례이다.


## 65,536 바이트 안에 컴파일러 맞추기

원래 "acwj" 컴파일러는 단일 실행 파일이었다. C 전처리기의 출력을 읽어 스캐닝, 파싱, 코드 생성을 수행하고 어셈블리 코드를 출력했다. 이 컴파일러는 각 함수에 대한 심볼 테이블과 AST 트리를 메모리에 유지했고, 한 번 사용한 데이터 구조는 해제하지 않았다.

이런 방식은 64K 메모리 안에 컴파일러를 맞추는 데 도움이 되지 않는다! 그래서 6809 자체 컴파일을 위해 다음과 같은 접근 방식을 선택했다:

1. 컴파일러를 여러 단계로 나눈다. 각 단계는 전체 컴파일 작업의 일부를 담당하고, 단계 간에는 중간 파일을 통해 데이터를 주고받는다.
2. 심볼 테이블과 AST 트리를 가능한 한 메모리에 적게 유지한다. 대신 이들을 파일에 저장하고 필요할 때 읽고 쓰는 함수를 사용한다.
3. 사용하지 않는 데이터 구조는 가능한 한 `free()`를 통해 가비지 컬렉션을 시도한다.

이제 이 세 가지를 차례로 살펴보자.


## 7단계 컴파일러 구조

이제 컴파일러는 7단계로 구성되며, 각 단계는 독립적인 실행 파일로 구현된다:

1. 외부 C 전처리기가 #include, #ifdef와 같은 전처리기 매크로를 해석한다.
2. 렉서(lexer)가 전처리기 출력을 읽어 토큰 스트림을 생성한다.
3. 파서(parser)가 토큰 스트림을 읽어 심볼 테이블과 AST(Abstract Syntax Tree) 트리 집합을 생성한다.
4. 코드 생성기가 AST 트리와 심볼 테이블을 사용해 어셈블리 코드를 생성한다.
5. 외부 피홀(peephole) 최적화기가 어셈블리 코드를 개선한다.
6. 외부 어셈블러가 오브젝트 파일을 생성한다.
7. 외부 링커가 `crt0.o`, 오브젝트 파일, 여러 라이브러리를 결합해 최종 실행 파일을 만든다.

이제 모든 단계를 조율하는 프론트엔드 프로그램인 [wcc.c](wcc.c)가 있다. 렉서는 `cscan`이라는 프로그램이고, 파서는 `cparse6809` 또는 `cparseqbe`이다. 코드 생성기는 `cgen6809` 또는 `cgenqbe`이며, 피홀 최적화기는 `cpeep`이다. 이 모든 프로그램은 `make install`을 통해 `/opt/wcc/bin`에 설치된다.

두 개의 코드 생성기가 있는 것은 이해할 수 있지만, 왜 두 개의 파서가 필요할까? 그 이유는 `sizeof(int)`, `sizeof(long)` 등의 크기가 각 아키텍처마다 다르기 때문이다. 따라서 파서도 코드 생성기와 마찬가지로 이 정보를 알아야 한다. 그래서 [targ6809.c](targ6809.c)와 [targqbe.c](targqbe.c) 파일이 파서와 코드 생성기에 컴파일된다.

> 참고: 6809에는 피홀 최적화기가 있다. QBE 백엔드는 `qbe` 프로그램을 사용해 QBE 코드를 x64 코드로 변환한다. 이것도 일종의 최적화라고 볼 수 있다 :-)


## 중간 파일

이 일곱 단계 사이에서는 각 단계의 출력을 저장할 중간 파일이 필요하다. 일반적으로 이 파일들은 컴파일이 끝나면 삭제되지만, `wcc`에 `-X` 커맨드라인 플래그를 사용하면 파일을 유지할 수 있다.

C 전처리기의 출력은 `_cpp`로 끝나는 임시 파일에 저장된다. 예를 들어 `fred.c`를 컴파일하면 `foo.c_cpp`와 같은 파일이 생성된다.

토큰화기의 출력은 `_tok`로 끝나는 임시 파일에 저장된다. 토큰 파일을 읽기 쉬운 형식으로 덤프할 수 있는 [detok.c](detok.c) 프로그램이 있다.

파서는 `_sym`으로 끝나는 심볼 테이블 파일과 `_ast`로 끝나는 파일에 저장되는 AST 트리 세트를 생성한다. 심볼 테이블과 AST 트리 파일을 덤프할 수 있는 [desym.c](desym.c)와 [detree.c](detree.c) 프로그램이 있다.

CPU와 상관없이 코드 생성기는 항상 최적화되지 않은 어셈블리 코드를 `_qbe`로 끝나는 파일에 출력한다. 이 파일은 `qbe`나 `cpeep`에 의해 읽혀 최적화된 어셈블리 코드를 생성하며, 이 코드는 `_s`로 끝나는 임시 파일에 저장된다.

어셈블러는 이 파일을 어셈블하여 `.o`로 끝나는 오브젝트 파일을 생성한다. 이 오브젝트 파일은 링커에 의해 최종 실행 파일로 연결된다.

다른 컴파일러와 마찬가지로, `wcc`는 어셈블리를 `.s`로 끝나는 파일에 출력하고 멈추는 `-S` 플래그와 오브젝트 파일을 출력하고 멈추는 `-c` 플래그를 지원한다.


## 심볼 테이블과 AST 파일의 형식

이 파일들에 대해 간단한 접근 방식을 사용했고, 분명 개선의 여지가 있다. 단순히 `struct symtable`과 `struct ASTnode` 노드( [defs.h](defs.h) 참조)를 `fwrite()`를 사용해 파일에 직접 기록한다.

이들 중 많은 부분이 관련 문자열을 가지고 있다. 예를 들어, 심볼 이름이나 문자열 리터럴을 포함하는 AST 노드가 있다. 이런 경우, 끝에 NUL 바이트를 포함한 문자열을 그대로 `fwrite()`로 기록한다.

노드를 다시 읽어오는 것은 간단하다. 각 구조체의 크기만큼 `fread()`를 사용하면 된다. 하지만 NUL로 끝나는 문자열이 있다면 이를 다시 읽어와야 한다. 이를 위한 적절한 C 라이브러리 함수가 없기 때문에, [misc.c](misc.c)에 `fgetstr()`라는 함수를 만들어 사용한다.

메모리 내 구조체를 디스크에 덤프할 때 발생하는 문제 중 하나는 구조체 내 포인터가 의미를 잃는다는 점이다. 구조체를 다시 로드하면 메모리의 다른 부분에 위치하게 되기 때문에, 모든 포인터 값은 유효하지 않게 된다.

이 문제를 해결하기 위해, 심볼 테이블 구조체와 ASTnode 구조체 모두 노드 자체와 노드가 가리키는 노드에 대한 숫자 ID를 추가했다.

```
// 심볼 테이블 구조체
struct symtable {
  char *name;                   // 심볼의 이름
  int id;                       // 심볼의 숫자 ID
  ...
  struct symtable *ctype;       // 구조체/공용체인 경우, 해당 타입을 가리키는 포인터
  int ctypeid;                  // 해당 타입의 숫자 ID
};

// 추상 구문 트리 구조체
struct ASTnode {
  ...
  struct ASTnode *left;         // 왼쪽, 중간, 오른쪽 자식 트리
  struct ASTnode *mid;
  struct ASTnode *right;
  int nodeid;                   // 트리가 직렬화될 때 노드 ID
  int leftid;                   // 직렬화될 때 숫자 ID
  int midid;
  int rightid;
  ...
};
```

두 구조체를 읽어오는 코드는 복잡하다. 노드를 찾고 다시 연결해야 하기 때문이다. 더 큰 문제는 파일의 어느 부분까지 메모리로 가져와 유지할 것인가이다.


## 메모리 내 구조 vs. 디스크 기반 구조

여기서 발생하는 문제는, 너무 많은 심볼 테이블과 AST 노드를 메모리에 유지하면 메모리가 부족해질 수 있다는 점이다. 반면에 이들을 파일로 저장하면 노드에 접근할 때마다 많은 파일 읽기/쓰기 작업을 해야 할 수도 있다.

이런 유형의 문제에서는 대개 충분히 좋은 성능을 내는 휴리스틱을 선택한다. 여기에 추가적인 제약 조건은, 훌륭한 성능을 내는 휴리스틱을 선택하더라도 그 구현에 많은 코드가 필요할 수 있고, 이 자체가 사용 가능한 메모리에 부담을 줄 수 있다는 점이다.

따라서 현재 내가 선택한 방법은 다음과 같다. 이 방법은 나중에 바꿀 수 있지만, 현재로서는 이 방식으로 진행한다.


## 심볼 테이블 노드 작성

파싱 단계에서 심볼을 찾고 타입 등을 결정한다. 이 과정에서 심볼을 파일에 기록하는 역할도 수행한다.

컴파일러의 주요 변경 사항 중 하나는 이제 여러 개의 테이블이 아니라 단일 심볼 테이블만 존재한다는 점이다. 통합된 테이블의 각 심볼은 구조적 타입과 가시성을 가진다([defs.h](defs.h) 참조):

```
// 심볼 테이블의 심볼은 다음 구조적 타입 중 하나다.
enum {
  S_VARIABLE, S_FUNCTION, S_ARRAY, S_ENUMVAL, S_STRLIT,
  S_STRUCT, S_UNION, S_ENUMTYPE, S_TYPEDEF, S_NOTATYPE
};

// 심볼의 가시성 클래스
enum {
  V_GLOBAL,                     // 전역적으로 접근 가능한 심볼
  V_EXTERN,                     // 외부에서 접근 가능한 전역 심볼
  V_STATIC,                     // 한 파일 내에서만 접근 가능한 정적 심볼
  V_LOCAL,                      // 로컬에서 접근 가능한 심볼
  V_PARAM,                      // 함수 파라미터로 접근 가능한 심볼
  V_MEMBER                      // 구조체 또는 공용체의 멤버
};
```

사실 약간의 과장이 있었다. 실제로는 세 개의 심볼 테이블이 존재한다: 일반 심볼을 위한 테이블, 타입(구조체, 공용체, 열거형, typedef)을 위한 테이블, 그리고 구조체, 공용체, 함수의 멤버 리스트를 작성하기 위한 임시 테이블.

[sym.c](sym.c) 파일에서 `serialiseSym()` 함수는 심볼 테이블 노드와 관련 문자열을 파일에 기록한다. 여기서 한 가지 최적화는 노드에 단조 증가하는 ID를 부여하므로, 이미 기록한 최고 심볼 ID를 기록해두고 해당 ID 이하의 심볼은 다시 기록하지 않는다.

같은 파일의 `flushSymtable()` 함수는 타입 리스트와 일반 심볼 리스트를 순회하며 각 노드를 `serialiseSym()`을 호출해 기록한다.

같은 파일의 `freeSym()` 함수는 심볼 항목이 차지하는 메모리를 해제한다. 이는 노드 자체, 관련 이름, 그리고 초기화 리스트(예: `int x= 27;`와 같은 전역 심볼)를 포함한다. 구조체, 공용체, 함수와 같은 심볼은 멤버 심볼 리스트도 가진다. 이는 구조체와 공용체의 필드, 함수의 로컬 변수와 파라미터를 포함한다. 이들도 함께 해제된다.

[sym.c](sym.c) 파일의 `freeSymtable()` 함수는 이 리스트를 순회하며 각 노드를 `freeSym()`을 호출해 해제한다.

이제 중요한 질문은 파서에서 언제 심볼 테이블을 flush하고 해제해도 안전한가이다. 답은 각 함수가 끝난 후 심볼 테이블을 flush할 수 있다는 것이다. 하지만 심볼 테이블을 해제할 수는 없다. 파서는 미리 정의된 타입과 심볼을 조회해야 하기 때문이다. 예를 들어:

```
  z= x + y;
```

이 변수들의 타입은 무엇이고 호환 가능한가? 이들은 로컬 변수인가, 파라미터인가, 전역 변수인가? 심지어 선언되었는가? 이를 위해 전체 심볼 테이블이 필요하다.

따라서 [decl.c](decl.c) 파일의 `function_declaration()` 함수 끝 부분에서:

```
  ...
  flushSymtable();
  Functionid= NULL;
  return (oldfuncsym);
}
```


## 심볼 테이블 노드 읽기

6809 코드 생성기는 코드 크기가 상당히 크다. 약 30K의 RAM을 사용하므로 남은 메모리를 낭비하지 않도록 주의해야 한다. 코드 생성기에서는 필요한 심볼만 로드한다. 각 심볼은 하나 이상의 심볼에 대한 정보를 필요로 할 수 있다. 예를 들어, 변수가 `struct foo` 타입일 경우, `struct foo` 심볼과 해당 구조체의 필드들에 대한 심볼을 모두 로드해야 한다.

문제는 심볼이 파싱된 순서대로 기록되지만, 심볼을 이름이나 ID로 찾아야 한다는 점이다. 예를 들어:

```
  struct foo x;
```

이 경우, `x` 심볼을 이름으로 검색해야 한다. 해당 노드는 `foo` 심볼에 대한 `ctypeid`를 가지고 있으므로, 이 ID로 심볼을 검색해야 한다.

이 작업의 대부분은 [sym.c](sym.c) 파일의 `loadSym()` 함수에서 처리된다:

```
// 심볼 테이블 노드 포인터가 주어지면, 디스크 상의 심볼 테이블에서 다음 항목을 읽어온다.
// loadit가 true일 경우 항상 이 작업을 수행한다.
// recurse가 0이면 하나의 노드만 읽는다.
// loadit가 false일 경우, 데이터를 로드하고 주어진 이름과 stype에 일치하거나 ID에 일치하는 심볼이면 true를 반환한다.
// 더 이상 읽을 것이 없으면 -1을 반환한다.
static int loadSym(struct symtable *sym, char *name,
                   int stype, int id, int loadit, int recurse) {
 ...
}
```

코드를 자세히 설명하지는 않겠지만, 몇 가지 주의할 점이 있다. `stype`과 `name`으로 검색할 수 있다. 예를 들어, S_FUNCTION 타입의 `printf()`를 찾을 수 있다. 숫자 ID로도 검색할 수 있다. 때로는 노드를 재귀적으로 가져와야 하는데, 이는 멤버를 가진 심볼(예: 구조체)이 기록될 때 멤버들이 바로 뒤에 따라오기 때문이다. 마지막으로, `loadit`가 설정되어 있으면 항상 다음 심볼을 읽어온다. 예를 들어, 멤버들을 읽을 때 사용된다.

`findSyminfile()` 함수는 매번 심볼 파일의 시작으로 돌아가서 `loadSym()`을 호출하며 루프를 돌면서 필요한 심볼을 찾거나 파일의 끝에 도달할 때까지 반복한다. 효율적이지는 않다.

이전 컴파일러 코드에는 다음과 같은 함수들이 있었다:

```
struct symtable *findlocl(char *name, int id);
struct symtable *findSymbol(char *name, int stype, int id);
struct symtable *findmember(char *s);
struct symtable *findstruct(char *s);
struct symtable *findunion(char *s);
struct symtable *findenumtype(char *s);
struct symtable *findenumval(char *s);
struct symtable *findtypedef(char *s);
```

이 함수들은 여전히 존재하지만 다르게 동작한다. 먼저 메모리에서 필요한 심볼을 검색하고, 메모리에 없으면 `findSyminfile()`을 호출한다. 파일에서 심볼이 로드되면 메모리 심볼 테이블에 연결된다. 따라서 코드 생성기가 필요로 하는 심볼들을 캐시로 쌓아두게 된다.

메모리를 절약하기 위해, 코드 생성기에서 주기적으로 심볼 테이블을 비우고 해제해야 한다. 코드 생성기의 메인 루프가 있는 [cgen.c](cgen.c) 파일에서:

```
  while (1) {
    // 파일에서 다음 함수의 최상위 노드를 읽어온다
    node= loadASTnode(0, 1);
    if (node==NULL) break;

    // 트리에 대한 어셈블리 코드를 생성한다
    genAST(node, NOLABEL, NOLABEL, NOLABEL, 0);

    // 메모리 심볼 테이블의 심볼들을 해제한다
    freeSymtable();
  }
```

컴파일러를 다시 작성할 때 한 가지 작은 문제가 있었다. 초기화된 전역 심볼들이 있고, 이들에 대한 어셈블리 명령어를 생성해야 한다는 점이다. 따라서 위 루프 바로 위에 `allocateGlobals()`라는 함수를 호출한다. 이 함수는 [sym.c](sym.c) 파일의 `loadGlobals()` 함수를 호출하여 전역 심볼들을 읽어온다. 이제 전역 심볼 리스트를 순회하면서 적절한 코드 생성기 함수를 호출할 수 있다. `allocateGlobals()`의 끝에서 `freeSymtable()`을 호출할 수 있다.

마지막으로 한 가지 더 언급할 점이 있다. 모든 C 프로그램에는 그리 많은 심볼이 없기 때문에 이 모든 것이 작동한다. 포함된 헤더 파일도 고려해야 하지만, 실제 Unix-like 시스템에서의 프로덕션 컴파일러라면 문제가 생길 것이다. 일반적인 프로그램은 수십 개의 헤더 파일을 포함하고, 각 헤더 파일에는 수십 개의 typedef, 구조체, 열거형 값 등이 있다. 이 경우 메모리가 금방 부족해질 것이다.

따라서 이 방법은 작동하지만 확장성이 없다.


## AST 노드 작성하기

이제 AST 노드에 대해 다룬다. 첫 번째로 짚어야 할 점은 함수의 AST 트리를 모두 메모리에 올린 후 쓰거나 읽을 만큼 충분한 메모리가 없다는 것이다. 처리해야 할 대형 함수들은 3,000개 이상의 AST 노드를 가질 수 있다. 이는 64KB RAM에 모두 담기에는 너무 크다.

따라서 메모리에는 제한된 수의 AST 노드만 유지해야 한다. 하지만 어떻게 가능할까? 결국 AST는 트리 구조다. 어떤 노드에 대해, 하위 트리가 필요한 시점과 트리를 정리할 수 있는 시점은 언제인가?

최상위 파서 파일 [parse.c](parse.c)에는 `serialiseAST()`라는 함수가 있다. 이 함수는 주어진 노드와 그 하위 노드를 디스크에 쓴다. 이 함수는 몇 군데에서 호출된다.

[stmt.c](stmt.c)의 `compound_statement()` 함수 내부:

```
  while (1) {
    ...
    // 단일 문장 파싱
    tree = single_statement();

    ...
        left = mkastnode(A_GLUE, P_NONE, NULL, left, NULL, tree, NULL, 0);

        // 메모리를 절약하기 위해 단일 문장 트리를 최적화한다.
        // 그런 다음 트리를 직렬화하고 메모리에서 해제한다.
        // left의 right 포인터를 NULL로 설정하면 직렬화기가 이미 직렬화한 트리로
        // 더 이상 내려가지 않는다.
        tree = optimise(tree);
        serialiseAST(tree);
        freetree(tree, 0);
    ...
  }
```

즉, 단일 문장이 있을 때마다 해당 문장을 파싱하고 AST 트리를 구축한 후 디스크에 덤프한다.

[decl.c](decl.c)의 `function_declaration()` 함수 끝부분:

```
  // 트리 직렬화
  serialiseAST(tree);
  freetree(tree, 0);

  // 메모리 상의 심볼 테이블을 비운다.
  // 더 이상 함수 내부가 아니다.
  flushSymtable();
  Functionid= NULL;

  return (oldfuncsym);
```

이 코드는 함수의 최상위 AST 노드를 식별하는 S_FUNCTION 노드를 쓴다.

위 코드 조각에서 `freetree()` 함수를 참조한다. 이 함수는 [tree.c](tree.c)에 정의되어 있다:

```
// 트리 내용을 해제한다. 트리 최적화로 인해
// left와 right가 동일한 하위 노드인 경우도 있다.
// 필요하다면 이름도 해제한다.
void freetree(struct ASTnode *tree, int freenames) {
  if (tree==NULL) return;

  if (tree->left!=NULL) freetree(tree->left, freenames);
  if (tree->mid!=NULL) freetree(tree->mid, freenames);
  if (tree->right!=NULL && tree->right!=tree->left)
                                        freetree(tree->right, freenames);
  if (freenames && tree->name != NULL) free(tree->name);
  free(tree);
}
```


## AST 노드 읽기

코드 생성기에서 AST 노드를 읽어들이는 좋은 방법을 찾기 위해 상당히 고민했다. 여기서 해결해야 할 두 가지 주요 과제가 있다:

1. 각 함수의 최상위 노드를 찾아서 읽어들인다.
2. AST 노드를 얻은 후, 해당 노드의 자식 노드들을 ID를 통해 읽어들인다.

처음에는 심볼 테이블과 마찬가지로 매번 파일의 시작 부분으로 되돌아가 검색을 시도했다. 하지만 이 방법은 1,000줄짜리 파일을 컴파일하는 데 약 45분이 걸렸다. 이는 분명히 좋은 방법이 아니다.

다음으로, 숫자 ID, 타입(S_FUNCTION 여부), 그리고 파일 오프셋을 메모리에 캐싱하는 방법을 고려했다. 하지만 이 방법도 적합하지 않았다. 각 AST 노드에 대해 다음과 같은 메모리가 필요하기 때문이다:

- ID: 2바이트
- S_FUNCTION 여부: 1바이트
- 파일 오프셋: 4바이트

예를 들어, 3,000개의 노드가 있는 AST 파일은 21,000바이트의 캐시를 필요로 한다. 이는 비효율적이다!

대신, 별도의 임시 파일에 노드 파일 오프셋 목록을 작성하기로 했다. 이 작업은 [tree.c](tree.c) 파일의 `mkASTidxfile()` 함수에서 수행된다. 이 파일은 단순히 4바이트 길이의 오프셋 값 시퀀스로 구성된다. 위치 0은 ID 0의 오프셋을, 위치 4는 ID 1의 오프셋을 저장하는 식이다.

각 함수의 최상위 노드를 순차적으로 찾아야 하며, 일반적으로 파일 내 함수의 수가 많지 않기 때문에, 모든 S_FUNCTION 노드의 오프셋을 메모리 내 목록에 기록하기로 결정했다.

[tree.c](tree.c) 파일에는 다음과 같은 코드가 있다:

```
// AST 파일 내 함수를 나타내는 AST 노드 오프셋 배열을 유지한다
long *Funcoffset;
```

이 배열은 `malloc()`과 `realloc()`을 통해 동적으로 할당되며, 모든 함수 오프셋을 포함하도록 확장된다. 마지막 값은 0인데, 이는 파서에서 ID 값 0이 할당되지 않기 때문이다.

이 정보를 어떻게 활용할까? 동일한 파일에 `loadASTnode()`라는 함수가 있다:

```
// 주어진 AST 노드 ID를 통해 AST 파일에서 해당 노드를 로드한다.
// nextfunc가 설정된 경우, 다음 함수 노드를 찾는다.
// 노드를 할당하고 반환하거나, 찾을 수 없는 경우 NULL을 반환한다.
struct ASTnode *loadASTnode(int id, int nextfunc) {
  ...
}
```

이 함수를 사용하면 특정 ID를 가진 노드를 로드하거나, 다음 S_FUNCTION 노드를 로드할 수 있다. 임시 파일에 저장된 오프셋을 활용해 원하는 노드가 메인 AST 파일 내에서 어디에 위치하는지 빠르게 찾을 수 있다. 간단하고 효과적인 방법이다!


## loadASTnode() 사용과 AST 노드 해제

안타깝게도 `loadASTnode()`를 호출할 수 있는 단일한 위치는 없다. [gen.c](gen.c)에 있는 아키텍처 독립적인 코드 생성 부분에서, 이전에 `n->left`, `n->mid`, `n->right` 포인터를 사용했던 모든 곳에서 이제는 `loadASTnode()`를 호출해야 한다. 예를 들면 다음과 같다.

```
// AST와 선택적 레이블, 그리고 부모의 AST 연산자를 받아
// 어셈블리 코드를 재귀적으로 생성한다.
// 트리의 최종 값을 담은 레지스터 ID를 반환한다.
int genAST(struct ASTnode *n, int iflabel, int looptoplabel,
           int loopendlabel, int parentASTop) {
  struct ASTnode *nleft, *nmid, *nright;

  // 하위 노드를 로드한다.
  nleft=loadASTnode(n->leftid,0);
  nmid=loadASTnode(n->midid,0);
  nright=loadASTnode(n->rightid,0);
  ...
}
```

[gen.c](gen.c)에서 약 15번 정도 `loadASTnode()`를 호출하는 것을 확인할 수 있다.

파서에서는 단일 문장을 파싱한 후, 디스크에 쓰기가 완료되면 `freetree()`를 호출할 수 있었다. 하지만 코드 생성기에서는 더 구체적으로 접근했다. AST 노드를 확실히 사용 완료한 후, [tree.c](tree.c)에 정의된 `freeASTnode()` 함수를 호출해 메모리를 해제했다. 코드 생성기에서 이 함수를 약 12번 정도 호출하는 것을 확인할 수 있다.

이것이 심볼 테이블과 AST 노드 처리에 대한 주요 변경 사항이다.


## 메모리 해제 일반론

컴파일러를 64K 메모리에 맞추려고 할 때 세 번째로 언급한 점은 사용하지 않는 데이터 구조를 `free()`로 가비지 컬렉션을 시도하는 것이었다.

C 언어는 가비지 컬렉션을 시도하기에 가장 부적합한 언어다. 한동안 `free()`를 사용할 만한 곳에 넣어보려고 시도했지만, 컴파일러는 세그먼트 폴트를 일으키거나, 더 나쁜 경우 이미 덮어씌워진 노드를 사용하면서 비정상적인 동작을 보였다.

다행히 네 가지 주요 함수를 통해 가비지 컬렉션을 할 수 있게 되었다: `freeSym()`, `freeSymtable()`, `freeASTnode()`, 그리고 `freetree()`.

이것이 모든 가비지 컬렉션 문제를 해결한 것은 아니다. 최근에는 [Valgrind](https://valgrind.org/)를 사용해 메모리 누수가 발생하는 위치를 찾고 있다. 가장 심각한 경우를 찾은 다음, `free()`를 삽입할 수 있는 위치를 파악해 개선하고 있다. 이 방법으로 컴파일러가 6809에서 자체 컴파일을 할 수 있을 정도까지는 되었지만, 여전히 개선의 여지가 많다!


## 피홀 최적화 도구

피홀 최적화 도구는 [cpeep.c](cpeep.c) 파일에 구현되어 있으며, 크리스천 W. 프레이저가 1984년에 처음 개발했다. [문서](docs/copt.1)를 보면 그 이후 여러 사람이 이 도구를 개선했다. 나는 이 도구를 [Fuzix Compiler Kit](https://github.com/EtchedPixels/Fuzix-Compiler-Kit)에서 임포트한 후 이름을 변경했다. 또한 규칙의 끝을 나타내는 방식을 빈 줄 대신 `====`로 바꿨다. 이렇게 하면 규칙이 끝나는 지점을 더 쉽게 확인할 수 있다.

6809 백엔드는 때때로 비효율적인 코드를 생성한다. 이 최적화 도구는 그런 코드를 제거하는 데 도움을 준다. [rules.6809](lib/6809/rules.6809) 파일을 살펴보면 어떤 규칙들이 적용되는지 확인할 수 있다. 나는 이 규칙들을 충분히 잘 설명했다고 생각한다. 또한 규칙이 제대로 동작하는지 확인하기 위해 [테스트 파일](tests/input.rules.6809)을 사용한다.


## 컴파일러 빌드 및 실행 - QBE

리눅스 환경에서 x68 코드를 출력하는 컴파일러를 빌드하려면 먼저 [QBE 1.2](https://c9x.me/compile/releases.html)를 다운로드하고, 빌드한 후 `qbe` 바이너리를 `$PATH`에 포함된 경로에 설치해야 한다.

다음으로 `/opt/wcc` 디렉토리를 생성하고 자신이 쓰기 권한을 가지도록 설정한다.

이제 `make; make install` 명령어를 실행하면 컴파일러가 빌드되고, 실행 파일은 `/opt/wcc/bin`에, 헤더 파일은 `/opt/wcc/include`에, 6809 라이브러리는 `/opt/wcc/lib/6809`에 설치된다.

이제 `/opt/wcc/bin/wcc`(컴파일러 프론트엔드)가 `$PATH`에 있는지 확인한다. 일반적으로 개인 `bin` 폴더에 심볼릭 링크를 만들어 사용한다.

여기서 `make test`를 실행하면 `tests/` 디렉토리로 이동해 해당 디렉토리에 있는 모든 테스트를 실행한다.


## 컴파일러 빌드 및 실행 - 6809

이 과정은 조금 복잡하다.

먼저 [Fuzix Bintools](https://github.com/EtchedPixels/Fuzix-Bintools)를 다운로드하고, 최소한 어셈블러 `as6809`와 링커 `ld6809`를 빌드해야 한다. 이제 이 도구들을 `$PATH`에 있는 디렉토리에 설치한다.

다음으로, [Fuzemsys](https://github.com/DoctorWkt/Fuzemsys) 프로젝트를 다운로드한다. 이 프로젝트에는 6809 바이너리를 실행하기 위해 필요한 6809 에뮬레이터가 포함되어 있다. `emulators/` 디렉토리로 이동한 후 `make emu6809`를 실행하여 에뮬레이터를 빌드한다. 빌드가 완료되면 이 에뮬레이터를 `$PATH`에 있는 디렉토리에 설치한다.

아직 하지 않았다면, 이전과 마찬가지로 `/opt/wcc` 디렉토리를 생성한 후 이 프로젝트로 돌아와 `make; make install`을 실행하여 설치한다. `/opt/wcc/bin/wcc`(컴파일러 프론트엔드)가 `$PATH`에 있는지 확인한다.

이제 `make 6test`를 실행할 수 있다. 이 명령어는 `tests/` 디렉토리로 이동하여 모든 테스트를 실행한다. 이번에는 6809 바이너리를 빌드하고 6809 에뮬레이터를 사용해 실행한다.


## QBE 트리플 테스트 수행하기

`qbe`를 설치하고 `make install; make test`를 실행해 컴파일러가 정상적으로 작동하는지 확인했다면, 이제 `make triple`을 실행할 수 있다. 이 명령어는 다음과 같은 작업을 수행한다:

1. 네이티브 컴파일러로 컴파일러를 빌드한다.
2. 컴파일러를 자기 자신으로 다시 빌드하여 `L1` 디렉터리에 저장한다.
3. 컴파일러를 다시 한 번 자기 자신으로 빌드하여 `L2` 디렉터리에 저장한다.
4. `L1`과 `L2` 디렉터리의 실행 파일 체크섬을 비교해 동일한지 확인한다:

```
0f14b990d9a48352c4d883cd550720b3  L1/detok
0f14b990d9a48352c4d883cd550720b3  L2/detok
3cc59102c6a5dcc1661b3ab3dcce5191  L1/cgenqbe
3cc59102c6a5dcc1661b3ab3dcce5191  L2/cgenqbe
3e036c748bdb5e3ffc0e03506ed00243  L2/wcc      <-- 다름
6fa26e506a597c9d9cfde7d168ae4640  L1/detree
6fa26e506a597c9d9cfde7d168ae4640  L2/detree
7f8e55a544400ab799f2357ee9cc4b44  L1/cscan
7f8e55a544400ab799f2357ee9cc4b44  L2/cscan
912ebc765c27a064226e9743eea3dd30  L1/wcc      <-- 다름
9c6a66e8b8bbc2d436266c5a3ca622c7  L1/cparseqbe
9c6a66e8b8bbc2d436266c5a3ca622c7  L2/cparseqbe
cb493abe1feed812fb4bb5c958a8cf83  L1/desym
cb493abe1feed812fb4bb5c958a8cf83  L2/desym
```

`wcc` 바이너리는 서로 다르다. 하나는 `L1` 경로를 사용해 단계별 실행 파일을 찾고, 다른 하나는 `L2` 경로를 사용하기 때문이다.


## 6809 삼중 테스트 수행

`Makefile` 대신 `6809triple_test`라는 별도의 Bash 쉘 스크립트를 사용한다. 이 스크립트를 실행하면 다음과 같은 작업을 수행할 수 있다:

- 네이티브 컴파일러로 컴파일러를 빌드한다.
- 6809 컴파일러를 스스로 사용해 `L1` 디렉터리에 빌드한다.
- 6809 컴파일러를 다시 스스로 사용해 `L2` 디렉터리에 빌드한다.

이 과정은 시간이 오래 걸린다. 성능이 괜찮은 노트북에서도 약 45분이 소요된다. 최종적으로 생성된 실행 파일이 동일한지 확인하려면 직접 체크섬을 계산해볼 수 있다:

```
$ md5sum L1/_* L2/_* | sort
01c5120e56cb299bf0063a07e38ec2b9  L1/_cgen6809
01c5120e56cb299bf0063a07e38ec2b9  L2/_cgen6809
0caee9118cb7745eaf40970677897dbf  L1/_detree
0caee9118cb7745eaf40970677897dbf  L2/_detree
2d333482ad8b4a886b5b78a4a49f3bb5  L1/_detok
2d333482ad8b4a886b5b78a4a49f3bb5  L2/_detok
d507bd89c0fc1439efe2dffc5d8edfe3  L1/_desym
d507bd89c0fc1439efe2dffc5d8edfe3  L2/_desym
e78da1f3003d87ca852f682adc4214e8  L1/_cscan
e78da1f3003d87ca852f682adc4214e8  L2/_cscan
e9c8b2c12ea5bd4f62091fafaae45971  L1/_cparse6809
e9c8b2c12ea5bd4f62091fafaae45971  L2/_cparse6809
```

현재 `wcc`를 6809 실행 파일로 실행하는 데 문제가 있어서, 대신 x64 `wcc` 바이너리를 사용하고 있다.


## 커맨드라인 작업 예제

위 작업을 수행하기 위해 사용한 커맨드라인 명령어를 정리했다:

```
# acwj 저장소 다운로드
cd /usr/local/src
git clone https://github.com/DoctorWkt/acwj

# 목적지 디렉토리 생성
sudo mkdir /opt/wcc
sudo chown wkt:wkt /opt/wcc

# QBE 설치
cd /usr/local/src
wget https://c9x.me/compile/release/qbe-1.2.tar.xz
xz -d qbe-1.2.tar.xz 
tar vxf qbe-1.2.tar 
cd qbe-1.2/
make
sudo make install

# wcc 컴파일러 설치
cd /usr/local/src/acwj/64_6809_Target
make install

# wcc를 $PATH에 추가
cd ~/.bin
ln -s /opt/wcc/bin/wcc .

# QBE를 사용해 x64에서 triple 테스트 실행
cd /usr/local/src/acwj/64_6809_Target
make triple

# Fuzix-Bintools 다운로드 및 
# 6809 어셈블러와 링커 빌드
cd /usr/local/src
git clone https://github.com/EtchedPixels/Fuzix-Bintools
cd Fuzix-Bintools/
make as6809 ld6809
cp as6809 ld6809 ~/.bin

# Fuzemsys 다운로드 및 6809 에뮬레이터 빌드
# readline 라이브러리 설치 필요
sudo apt-get install libreadline-dev
cd /usr/local/src
git clone https://github.com/DoctorWkt/Fuzemsys
cd Fuzemsys/emulators/
make emu6809
cp emu6809 ~/.bin

# 컴파일러로 돌아가 6809 에뮬레이터를 사용해
# triple 테스트 실행
cd /usr/local/src/acwj/64_6809_Target
./6809triple_test 
```


## 이 컴파일러는 자체 컴파일이 가능한가?

6809 CPU로 세 가지 테스트를 통과할 수 있다. 하지만 이 컴파일러가 진정한 의미의 자체 컴파일이 가능한가? 그렇다. 그러나 확실히 자체 호스팅은 아니다.

이 C 컴파일러가 생성하지 않는 것들은 다음과 같다:

- C 전처리기
- 피홀 최적화 도구
- 6809 어셈블러
- 6809 링커
- 6809용 `ar` 아카이버
- 컴파일러 헬퍼 함수와 C 라이브러리. 현재는 Fuzix Compiler Kit을 사용해 이 함수들을 빌드한다. Fuzix Compiler는 '진짜' C를 지원하지만, 이 컴파일러는 C 언어의 일부만 지원하기 때문에 이 함수들을 빌드할 수 없다.

따라서 [MMU09 SBC](https://github.com/DoctorWkt/MMU09)로 모든 것을 옮기려면 Fuzix Compiler를 사용해 어셈블러, 링커, 헬퍼 함수, 그리고 C 라이브러리를 빌드해야 한다.

결론적으로, "acwj" 컴파일러는 전처리된 C 소스 코드를 받아 스캐너, 파서, 코드 생성기를 통해 6809 어셈블리 코드를 출력할 수 있다. 또한 "acwj" 컴파일러는 자신의 코드에 대해 위 과정을 수행할 수 있다.

이로 인해 이 컴파일러는 자체 컴파일이 가능하지만, 자체 호스팅은 아니다!


## 향후 작업

현재 이 컴파일러는 프로덕션 수준이 아니다. 심지어 제대로 된 C 컴파일러도 아니다. C 언어의 일부만 지원한다.

앞으로 해야 할 작업은 다음과 같다:

- 더 견고하게 만들기
- 가비지 컬렉션을 제대로 처리하기
- 부호 없는 타입 추가하기
- float와 double 타입 추가하기
- 실제 C 언어의 더 많은 기능을 추가해 자체 호스팅 가능하게 만들기
- 6809 코드 생성기의 품질 개선하기
- 6809 컴파일러의 속도 향상하기
- 또는, 이 모든 과정에서 배운 교훈을 바탕으로 큰 발걸음을 내딛어 완전히 새로운 컴파일러를 처음부터 다시 작성하기!


## 마치며

이번 파트를 마치며 꽤 지치게 되었다. [노트](docs/NOTES.md)를 보면 알 수 있듯이 몇 달간의 작업이었다. 이제 "acwj" 여정의 64번째 파트까지 왔다. 2의 거듭제곱으로 보기 좋은 숫자다.

확실히 끝이라고 말하진 않겠지만, 이쯤에서 "acwj" 여정을 마무리하려고 한다. 여러분이 일부 혹은 대부분, 또는 모든 파트를 따라와 주었다면, 내 노트를 읽는 데 시간을 할애해 준 것에 감사드린다. 이 내용이 유용했기를 바란다.

이제 여러분에게 8비트나 16비트 CPU를 위한 일종의 C 컴파일러가 필요하다면, 여기서 시작점을 찾을 수 있을 것이다.

건배, Warren


