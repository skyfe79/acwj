# 22부: 지역 변수와 함수 호출을 위한 설계 아이디어

이번은 컴파일러 작성 여정에서 새로운 코드를 소개하지 않는 첫 번째 파트이다. 이번에는 코더의 키보드에서 잠시 물러나 큰 그림을 보는 시간을 가져야 한다. 이 기회를 통해 지역 변수 구현(이번 파트)과 함수 인자 및 매개변수(다음 파트)를 어떻게 구현할지 고민할 수 있다.

이 두 단계 모두 기존 컴파일러에 상당한 추가와 변경이 필요하다. 또한 *스택 프레임*과 *레지스터 스필* 같은 새로운 개념도 다뤄야 한다. 지금까지는 이 부분을 생략했었다.

먼저 컴파일러에 추가할 새로운 기능이 무엇인지 파악해 보자.


## 우리가 원하는 기능

### 지역 변수와 전역 변수의 스코프

현재 모든 변수는 모든 함수에서 전역적으로 접근할 수 있다. 우리는 각 함수가 자신만의 변수를 가지도록 [지역 스코프](https://en.wikipedia.org/wiki/Scope_(computer_science))를 추가하려 한다. 이렇게 하면 다른 함수에서 해당 변수를 볼 수 없다. 또한 재귀 함수의 경우, 동일한 함수의 각 인스턴스가 자신만의 지역 변수를 가진다.

하지만 우리는 두 가지 스코프만 추가할 것이다: *지역*과 *전역*. C 언어는 실제로 모든 복합 문에 대해 새로운 스코프를 생성한다. 다음 예제에서는 세 가지 다른 스코프에 세 가지 다른 `a` 변수가 존재한다:

```c
#include <stdio.h>
int a = 2;              // 전역 스코프

int main()
{
  int a= 5;             // 지역 스코프
  if (a > 2) {
    int a= 17;          // 세 번째 스코프
    printf("%d\n", a);  // 17 출력
  }
  printf("%d\n", a);    // 5 출력
  return(0);
}
```

나는 세 번째, 내부 스코프는 지원하지 않을 것이다. 두 가지 스코프면 충분하다!


### 함수 매개변수를 지역 변수로 처리하기

함수는 0개 이상의 *매개변수*를 선언할 수 있다. 이 매개변수들은 해당 함수 인스턴스에 국한된 지역 변수로 처리되어야 한다.

C 언어의 함수는 "[값에 의한 호출(call by value)](https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value)" 방식을 따른다. 함수를 호출할 때 전달한 인자 값은 함수의 매개변수로 복사된다. 이렇게 복사된 값을 통해 호출된 함수는 매개변수를 사용하거나 수정할 수 있다.


### 스택 소개

동일한 함수의 여러 인스턴스에 대해 로컬 스코프를 만들고, 함수의 매개변수를 저장할 공간을 제공하기 위해 **스택**이 필요하다. 스택에 대해 잘 모른다면, 먼저 [위키피디아의 콜 스택 문서](https://en.wikipedia.org/wiki/Call_stack)를 읽어보는 것이 좋다.

우리가 지원하는 하드웨어 아키텍처 중 하나인 Linux에서 실행되는 Intel x86-64 아키텍처를 고려할 때, 이 아키텍처에서 함수 호출 메커니즘을 구현해야 한다. Eli Bendersky가 작성한 [x86-64 스택 프레임 레이아웃](https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/) 문서는 이 문서를 계속 읽기 전에 반드시 읽어야 할 자료다. Eli의 문서는 공개 도메인에 있으므로, 아래에 그의 스택 프레임과 레지스터에 있는 매개변수 그림을 재현한다. 이 그림은 다음 함수를 설명한다:

```c
long myfunc(long a, long b, long c, long d,
            long e, long f, long g, long h)
{
    long xx, yy, zz;
    ...
}
```

![](Figs/x64_frame_nonleaf.png)

기본적으로 x86-64 아키텍처에서는 일부 매개변수 값이 레지스터로 전달되고, 일부는 스택에 푸시된다. 모든 로컬 변수는 스택에 있지만 스택 베이스 포인터 아래에 위치한다.

동시에, 우리는 컴파일러가 다양한 아키텍처에 이식 가능하도록 만들고 싶다. 따라서 스택만 사용하거나, 레지스터만 사용하거나, 또는 둘 다를 사용하는 다양한 아키텍처를 지원하기 위해 일반적인 함수 매개변수 프레임워크가 필요하다.


### 레지스터 스필링

지금까지 다루지 않았고 아직 구현하지 않은 부분이 바로 [레지스터 스필링](https://en.wikipedia.org/wiki/Register_allocation#Spilling)이다. 몇 가지 이유로 할당된 레지스터 중 일부 또는 전부를 스필링해야 한다:

 + 레지스터는 고정된 개수만 존재하므로, 더 이상 할당할 레지스터가 부족한 경우가 있다. 이때 레지스터를 스택에 스필링하면 해당 레지스터를 다시 할당할 수 있게 된다.
 + 함수 호출 전에 할당된 모든 레지스터와 파라미터가 저장된 레지스터를 스택에 스필링해야 한다. 이렇게 하면 호출된 함수가 해당 레지스터를 사용할 수 있게 된다.

함수 호출이 끝나고 반환될 때는 필요한 값을 다시 얻기 위해 레지스터를 언스필링해야 한다. 마찬가지로, 레지스터를 비우기 위해 스필링한 경우, 해당 레지스터가 다시 사용 가능해지면 이전 값을 언스필링하고 재할당해야 한다.


### 정적 변수

즉시 구현할 항목 목록에는 포함되지 않았지만, 언젠가는 [정적 변수](https://en.wikipedia.org/wiki/Static_variable)를 할당해야 할 필요가 있다. 로컬 정적 변수의 경우 이름 지정 문제가 발생할 수 있지만, 우선순위가 높은 아이디어들을 구현하면서 이 문제를 계속 염두에 두려고 한다.


### 변수 초기화

변수를 선언할 때 초기화를 허용해야 한다. 전역 변수의 경우 상수 값으로 초기화하는 것은 가능하다. 예를 들어 `int x = 7;`과 같이 설정할 수 있다. 하지만 표현식으로 초기화하는 것은 불가능하다. 전역 변수는 [함수 컨텍스트](https://en.wikipedia.org/wiki/Scope_(computer_science)#Function_scope)가 없기 때문에 초기화 코드를 실행할 수 없기 때문이다.

반면, 지역 변수 초기화는 가능해야 한다. 예를 들어 `int a = 2, b = a + 5;`와 같은 방식으로 초기화할 수 있다. 이 경우 함수 코드의 시작 부분에 변수 초기화 코드를 삽입할 수 있기 때문이다.


## 아이디어와 구현

현재 디자이너의 머릿속에서 떠오르는 아이디어와 고민 사항들을 정리했다. 이 중 일부를 어떻게 구현할지에 대한 계획을 공유한다.


### 로컬 심볼

먼저 로컬 변수와 전역 변수의 차이점부터 살펴보자. 전역 변수는 모든 함수에서 접근할 수 있어야 하지만, 로컬 변수는 단일 함수 내에서만 접근할 수 있다.

SubC는 하나의 심볼 테이블을 사용해 로컬 변수와 전역 변수 정보를 모두 저장한다. 전역 변수는 테이블의 한쪽 끝에 할당되고, 로컬 변수는 반대쪽 끝에 저장된다. 두 영역이 중간에서 충돌하지 않도록 하는 코드가 존재한다. 이 방식은 심볼의 스코프와 상관없이 모든 심볼에 대해 고유한 슬롯 번호를 부여할 수 있어 유용하다.

로컬 심볼을 전역 심볼보다 우선적으로 처리하려면, 심볼 테이블의 로컬 영역을 먼저 검색하고, 해당 심볼을 찾지 못하면 전역 영역을 검색하면 된다. 또한 함수 파싱이 끝나면 심볼 테이블의 로컬 영역을 간단히 지울 수 있다.


### 스토리지 클래스

C 언어에는 [스토리지 클래스](https://en.wikipedia.org/wiki/C_syntax#Storage_class_specifiers) 개념이 있다. 우리는 이 클래스 중 일부를 구현해야 한다. SubC는 여러 스토리지 클래스를 구현한다:

```c
/* 스토리지 클래스 */
enum {
        CPUBLIC = 1,            // 공개적으로 접근 가능한 심볼
        CEXTERN,                // extern 심볼
        CSTATIC,                // 전역 컨텍스트에서의 static 심볼
        CLSTATC,                // 지역 컨텍스트에서의 static 심볼
        CAUTO,                  // non-static 지역 식별자
        CSPROTO,                // 함수 프로토타입
        CMEMBER,                // 구조체/공용체의 필드
        CSTCDEF                 // 미사용
};
```

이 클래스는 심볼 테이블의 각 심볼에 적용된다. 이 구조를 수정하여 사용할 수 있을 것이다. 하지만 아마도 더 적은 수의 스토리지 클래스 타입만 지원할 것이다.


### 함수 프로토타입

모든 함수는 *프로토타입*을 가진다. 여기에는 함수가 받는 매개변수의 개수와 타입이 포함된다. 함수 호출 시 전달된 인자가 함수 매개변수의 타입과 개수와 일치하는지 확인하기 위해 이 정보가 필요하다.

함수 프로토타입을 저장할 적절한 위치를 고민해야 한다. 함수 프로타타입을 위한 별도의 데이터 구조를 만들 수도 있다. 이 언어에서는 2차원 배열을 지원하지 않지만, 각 함수의 기본 타입 목록은 필요하다.

기존 심볼 테이블 엘리먼트의 타입으로 S_FUNCTION을 이미 사용하고 있다. 각 심볼 테이블 엔트리에 "매개변수 개수" 필드를 추가해 함수가 가진 매개변수의 수를 저장할 수 있다. 그리고 이 심볼 바로 뒤에 각 함수 매개변수에 대한 심볼 테이블 엔트리를 추가한다.

함수의 매개변수 목록을 파싱할 때, 전역 심볼 섹션에 매개변수를 추가해 함수 프로토타입을 기록한다. 동시에 매개변수를 지역 심볼 섹션의 엔트리로도 추가한다. 이 매개변수들은 함수 내에서 지역 변수로 사용될 것이다.

함수 호출 시 전달된 인자 목록이 함수 프로토타입과 일치하는지 확인하려면, 함수의 전역 심볼 테이블 엔트리를 찾은 다음, 심볼 테이블의 다음 엔트리들을 인자 목록과 비교하면 된다.

마지막으로, 전역 심볼을 검색할 때 함수의 "매개변수 개수" 필드를 로드해 해당 수만큼 심볼 테이블 엔트리를 건너뛰면 함수 매개변수 엔트리를 쉽게 건너뛸 수 있다.


### 레지스터에 매개변수 유지: 불가능한 이유

이 섹션은 실제로 위 내용을 구현하려고 시도한 후 작성했다. 그래서 설계를 다시 살펴보게 되었다. 처음에는 매개변수를 레지스터에 그대로 유지할 수 있을 거라고 생각했다. 이렇게 하면 매개변수에 접근하는 속도가 빨라지고 스택 프레임의 크기도 줄일 수 있을 것 같았다. 하지만 이 방법이 항상 가능한 것은 아니라는 사실을 깨달았다. 다음 코드를 살펴보자:

```c
void myfunction(int a) {        // a는 레지스터에 있는 매개변수
  int b;                        // b는 스택에 있는 지역 변수

  // a와 b를 업데이트하는 함수 호출
  b = function2(&a);
}
```

`a` 매개변수가 레지스터에 있다면, `&` 연산자로 주소를 가져올 수 없다. 따라서 어딘가 메모리로 복사해야 한다. 매개변수는 함수 내에서 지역 변수와 마찬가지이므로, 결국 스택으로 복사해야 한다.

한동안 AST를 순회하며 어떤 매개변수가 실제 주소를 필요로 하는지 찾는 아이디어를 고민했다. 하지만 KISS 원칙(Keep It Simple, Stupid!)을 떠올렸다. 그래서 모든 매개변수를 레지스터에서 스택으로 복사하기로 결정했다.


### 로컬 변수의 위치

파라미터나 로컬 변수가 스택에 복사되거나 배치된 후, 그 위치를 어떻게 확인할 수 있을까? 이를 위해 각 로컬 심볼 테이블 항목에 `posn` 필드를 추가한다. 이 필드는 프레임 베이스 포인터 아래로부터의 변수 오프셋을 나타낸다.

[C 문법의 BNF](https://www.lysator.liu.se/c/ANSI-C-grammar-y.html)를 보면, 함수 선언 목록(즉, 함수 파라미터 목록)이 로컬 변수 선언 목록보다 먼저 나오고, 이는 문장 목록보다 앞에 위치한다.

이는 파라미터와 로컬 변수를 파싱할 때, 문장 목록을 파싱하기 전에 스택 상의 위치를 미리 결정할 수 있음을 의미한다.


## 마무리 및 다음 단계

여기까지가 컴파일러 작성 과정에서 디자인 측면에서 하고 싶었던 모든 작업이다. 다음 단계에서는 지역 변수를 다룰 예정이고, 그다음 단계에서 함수 호출과 매개변수를 추가할 계획이다. 하지만 새로운 기능을 모두 구현하려면 세 단계 이상이 필요할 수도 있다. 진행하면서 확인해 보자. [다음 단계](../23_Local_Variables/Readme.md)


